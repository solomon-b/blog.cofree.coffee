<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Solomon Bothwell" />
  <meta name="dcterms.date" content="2021-11-15" />
    <title>Adding Spans To Alex and Happy</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="runner1">SOLOMON'S BLOG</div>
<div id="runner1b">functional programming, permaculture, math</div>
<header id="title-block-header">
<h1 class="title">Adding Spans To Alex and Happy</h1>
<p class="date">2021-11-15</p>
</header>
<p>In the <a href="https://blog.cofree.coffee/2021-11-08-happy-and-alex-mvp/">last post</a> we wrote a simple parser for untyped lambda calculus. We deferred tracking source positions (spans) and proper error handling. In this post we</p>
<p>We are going to start off by rewriting the lexer without the <code>basic</code> wrapper, then we will add source positions, and lastly we will rewrite the parser to includ spans in the final AST.</p>
<p>Alex actually comes with a wrapper which adds source positions out of the box. However, I want to show how to write a lexer without any wrappers so you can see that there really isn't any magick going on. This should give you a good understanding of how Alex works and how you might extend it in other bespoke ways.</p>
<h1 id="alex-with-no-wrappers">Alex With No Wrappers</h1>
<p>The <code>basic</code> wrapper provided us with 1 type alias and 4 functions:</p>
<ol>
<li><code>type AlexInput = (Char, [Word8], String)</code> - A triple representing the current state of the lexer. The first value is the last consumed <code>Char</code>, the second value is the remaining bytes in the current <code>Char</code>, and the third is the remaining input <code>String</code>.</li>
<li><code>alexScanTokens :: String -&gt; [token]</code> - The entrypoint to our lexer.</li>
<li><code>alexGetByte :: AlexInput -&gt; Maybe (Word8, AlexInput)</code> - A helper function for extracting the next byte of the current <code>Char</code> in the <code>AlexInput</code>. This is used internally by Alex for scanning our input <code>String</code>.</li>
<li><code>alexInputPrevChar :: AlexInput -&gt; Char</code> - A helper function to grab the last consumed <code>Char</code> from the <code>AlexInput</code>.</li>
<li><code>utf8encode' :: Char -&gt; (Word8, [Word8])</code> - A helper function to encode a single Haskell Char to a non-empty list of Word8 values, in UTF8 format. This could be replaced by <a href="https://hackage.haskell.org/package/utf8-string-1.0.2/docs/Codec-Binary-UTF8-String.html#v:encodeChar">encodeChar</a>.</li>
</ol>
<p>The last 3 functions are used internally by the Alex scanner when consuming characters. We will only be <em>directly</em> calling <code>alexScanTokens</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alexScanTokens ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>alexScanTokens str <span class="ot">=</span> go (<span class="ch">&#39;\n&#39;</span>,[],str)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    go inp__<span class="op">@</span>(_,_bs,s) <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> alexScan inp__ <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AlexEOF</span> <span class="ot">-&gt;</span> []</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AlexError</span> _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;lexical error&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AlexSkip</span>  inp__&#39; _ln     <span class="ot">-&gt;</span> go inp__&#39;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AlexToken</span> inp__&#39; len act <span class="ot">-&gt;</span> act (<span class="fu">take</span> len s) <span class="op">:</span> go inp__&#39;</span></code></pre></div>
<p><code>alexScanTokens</code> recursively calls <code>alexScan</code>, the entrypoint into the actual Alex scanner subroutine defined in the <a href="https://github.com/simonmar/alex/blob/ab87af1803a5e2f2c09b09eb024dc6ec9f44b0e3/src/Scan.hs#L297">Scan module</a>. <code>alexScan</code>'s type is <code>AlexInput -&gt; StartCode -&gt; AlexReturn a</code> and in broad strokes it peels off <code>Chars</code> from the input <code>String</code> and uses them to a construct a token in the <code>AlexReturn</code> sum type.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AlexReturn</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">AlexEOF</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">AlexError</span>  <span class="op">!</span><span class="dt">AlexInput</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">AlexSkip</span>   <span class="op">!</span><span class="dt">AlexInput</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">AlexToken</span>  <span class="op">!</span><span class="dt">AlexInput</span> <span class="op">!</span><span class="dt">Int</span> a</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">alexScan ::</span> <span class="dt">AlexInput</span> <span class="ot">-&gt;</span> <span class="dt">StartCode</span> <span class="ot">-&gt;</span> <span class="dt">AlexReturn</span> a</span></code></pre></div>
<p>Every call to <code>alexScan</code> in <code>alexScanTokens</code> will attempt to consume characters from the <code>String</code> in the <code>AlexInput</code> triple and produces a <code>AlexReturn</code> value. If characters are consumed then it returns an updated <code>AlexInput</code> and a count of the number of characters consumed.</p>
<p>Notice how in the <code>AlexToken</code> case it also produces some value of type <code>a</code>. Now look at how that <code>a</code> (bound as <code>act</code>) is is used in <code>alexScanTokens</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>go inp__<span class="op">@</span>(_,_bs,s) <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> alexScan inp__ <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">AlexToken</span> inp__&#39; len act <span class="ot">-&gt;</span> act (<span class="fu">take</span> len s) <span class="op">:</span> go inp__&#39;</span></code></pre></div>
<p><code>act</code> is actually a function which takes a string of characters peeled off the remaining <code>String</code> input from the <code>AlexInput</code> triple and returns a token. The length of that <code>String</code> is the number of characters consumed by <code>alexScan</code>.</p>
<p><code>act</code> is thus <code>String -&gt; Token</code> and is in fact the Haskell function we defined in our Alex grammar rules for whichever regex matched. We can verify that by changing the call site of <code>act</code> into a type hole:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>• <span class="dt">Found</span> hole<span class="op">:</span><span class="ot"> _act ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Where</span><span class="op">:</span> ‘a’ is a rigid <span class="kw">type</span> variable bound by</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>       the inferred <span class="kw">type</span> <span class="kw">of</span><span class="ot"> go ::</span> <span class="dt">AlexInput</span> <span class="ot">-&gt;</span> [a]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>       at app<span class="op">/</span>basic<span class="op">-</span>no<span class="op">-</span>wrapper<span class="op">/</span>Lexer.x<span class="op">:</span>(<span class="dv">62</span>,<span class="dv">9</span>)<span class="op">-</span>(<span class="dv">67</span>,<span class="dv">73</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Or</span> perhaps ‘_act’ is mis<span class="op">-</span>spelled, <span class="fu">or</span> <span class="fu">not</span> <span class="kw">in</span> scope</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>• <span class="dt">Relevant</span> bindings include</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    act ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  (bound at app<span class="op">/</span>basic<span class="op">-</span>no<span class="op">-</span>wrapper<span class="op">/</span>Lexer.x<span class="op">:</span><span class="dv">67</span><span class="op">:</span><span class="dv">38</span>)</span></code></pre></div>
<p>Now we can see that <code>alexScanTokens</code> works by recursively attempting to regex match the remainder of the input string using the regexes we provided in our grammar rules. If a match succeeds then the matching characters are passed into the corresponding Haskell function to produce a lexeme token and then we recurse on the remainder of the <code>String</code> building up our <code>[Token]</code>.</p>
<h1 id="source-positions">Source Positions</h1>
<p>Now that we have a better sense of what is Alex is doing, we can start to think about to add support for source positions.</p>
<p>The first thing we want to do is create a source position type and add it to <code>AlexInput</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AlexSourcePos</span> <span class="ot">=</span> <span class="dt">AlexSourcePos</span> {<span class="ot"> line ::</span> <span class="op">!</span><span class="dt">Int</span> ,<span class="ot"> col ::</span> <span class="op">!</span><span class="dt">Int</span> }</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AlexInput</span> <span class="ot">=</span> <span class="dt">AlexInput</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> currentPos ::</span> <span class="dt">AlexSourcePos</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> prevChar   ::</span> <span class="dt">Char</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> pendingBytes ::</span> [<span class="dt">Word8</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ^ pending bytes on current char</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> inputString ::</span> <span class="dt">String</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ^ current input string</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>I went ahead and changed <code>AlexInput</code> into a record type at the same time. Now every time we produce a new <code>AlexInput</code> we will want to update the <code>currentPos</code> based on the characters we consumed. For that we will want a helper function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alexMove ::</span> <span class="dt">AlexSourcePos</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">AlexSourcePos</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>alexMove (<span class="dt">AlexSourcePos</span> l c) <span class="ch">&#39;\t&#39;</span> <span class="ot">=</span> <span class="dt">AlexSourcePos</span> l (c<span class="op">+</span>alex_tab_size<span class="op">-</span>((c<span class="op">-</span><span class="dv">1</span>) <span class="ot">`mod`</span> alex_tab_size))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>alexMove (<span class="dt">AlexSourcePos</span> l _) <span class="ch">&#39;\n&#39;</span> <span class="ot">=</span> <span class="dt">AlexSourcePos</span> (l<span class="op">+</span><span class="dv">1</span>) <span class="dv">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>alexMove (<span class="dt">AlexSourcePos</span> l c) _    <span class="ot">=</span> <span class="dt">AlexSourcePos</span> l (c<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="ot">alexStartPos ::</span> <span class="dt">AlexSourcePos</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>alexStartPos <span class="ot">=</span> <span class="dt">AlexSourcePos</span> <span class="dv">1</span> <span class="dv">1</span></span></code></pre></div>
<p><code>alexMove</code> increments by preconfigured number of columns when encountering a tab, increments by a row when encountering a newline, and otherwise increments the column by 1. <code>alexStartPos</code> is a convenience function to produce our starting source position.</p>
<p>We now need to update <code>alexGetByte</code> to use our new <code>AlexInput</code> record and to use <code>AlexMove</code> to construct the <code>currentPos</code> when we fetch the next byte.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alexGetByte ::</span> <span class="dt">AlexInput</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Word8</span>, <span class="dt">AlexInput</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>alexGetByte (<span class="dt">AlexInput</span> p c (b<span class="op">:</span>bs) s) <span class="ot">=</span> <span class="dt">Just</span> (b, <span class="dt">AlexInput</span> p c bs s)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>alexGetByte (<span class="dt">AlexInput</span> _ _ [] []) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>alexGetByte (<span class="dt">AlexInput</span> p _ [] (c<span class="op">:</span>s))  <span class="ot">=</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p&#39; <span class="ot">=</span> alexMove p c</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="kw">case</span> utf8Encode&#39; c <span class="kw">of</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    (b, bs) <span class="ot">-&gt;</span> p&#39; <span class="ot">`seq`</span> <span class="dt">Just</span> (b, <span class="dt">AlexInput</span> p&#39; c bs s)</span></code></pre></div>
<p>When <code>alexGetByte</code> is fetching the <em>first</em> the first byte of a <code>Char</code> we update the <code>currentPos</code> for the entire <code>Char</code>, otherwise we carry on shuffling bytes.</p>
<p>Now we update <code>alexScanTokens</code> to use the new record type and we have access to the current source position as we consume characters:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alexScanTokens ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>alexScanTokens str <span class="ot">=</span> go (<span class="dt">AlexInput</span> alexStartPos <span class="ch">&#39;\n&#39;</span> [] str)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go inp<span class="op">@</span>(<span class="dt">AlexInput</span> __ _ _ str) <span class="ot">=</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> alexScan inp <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">AlexEOF</span> <span class="ot">-&gt;</span> []</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">AlexError</span> (<span class="dt">AlexInput</span> (<span class="dt">AlexSourcePos</span> line column) _ _ _) <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;lexical error at &quot;</span> <span class="op">++</span> (<span class="fu">show</span> line) <span class="op">++</span> <span class="st">&quot; line, &quot;</span> <span class="op">++</span> (<span class="fu">show</span> column) <span class="op">++</span> <span class="st">&quot; column&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">AlexSkip</span>  inp&#39; len     <span class="ot">-&gt;</span> go inp&#39;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">AlexToken</span> inp&#39; len act <span class="ot">-&gt;</span> act (<span class="fu">take</span> len str) <span class="op">:</span> go inp&#39;</span></code></pre></div>
<p>Since our <code>Token</code> type doesn't hold source positions we are throwing them away as we scan and the only place they end up being useful is when throwing lex errors.</p>
<p>However, we can easily wrap our <code>Token</code> type with a record that also holds source positions and pass that information along to our parser:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TokenExt</span> <span class="ot">=</span> <span class="dt">TokenExt</span> {<span class="ot"> token ::</span> <span class="dt">Token</span>,<span class="ot"> sourcePos ::</span> <span class="dt">AlexSourcePos</span> }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>To use <code>TokenExt</code> we need to update our grammar rules and <code>alexScanTokens</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(λ<span class="op">|</span>\\)                        { \pos _ <span class="ot">-&gt;</span> <span class="dt">TokenExt</span> <span class="dt">Lambda</span> pos }</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>\<span class="op">.</span>                            { \pos _ <span class="ot">-&gt;</span> <span class="dt">TokenExt</span> <span class="dt">Dot</span> pos }</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>\(                            { \pos _ <span class="ot">-&gt;</span> <span class="dt">TokenExt</span> <span class="dt">OpenParen</span> pos }</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>\)                            { \pos _ <span class="ot">-&gt;</span> <span class="dt">TokenExt</span> <span class="dt">CloseParen</span> pos }</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>alpha [<span class="op">$</span>alpha <span class="op">$</span>digit \_ \<span class="op">-</span>]<span class="op">*</span> { \pos s <span class="ot">-&gt;</span> <span class="dt">TokenExt</span> (<span class="dt">Identifier</span> s) pos }</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alexScanTokens ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">TokenExt</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>alexScanTokens str <span class="ot">=</span> go (<span class="dt">AlexInput</span> alexStartPos <span class="ch">&#39;\n&#39;</span> [] str)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go inp<span class="op">@</span>(<span class="dt">AlexInput</span> pos _ _ str) <span class="ot">=</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> alexScan inp <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">AlexToken</span> inp&#39; len act <span class="ot">-&gt;</span> act pos (<span class="fu">take</span> len str) <span class="op">:</span> go inp&#39;</span></code></pre></div>
<p>We rewrite our grammar rules to apply a function <code>AlexSourcePos -&gt;
String -&gt; TokenExt</code> and then update the <code>AlexToken</code> case of <code>alexScan</code> to apply the current source position to <code>act</code> along without the matched characters from the <code>String</code>.</p>
<p>And now we can carry on our source positions into the parser.</p>
<h1 id="updating-the-parser">Updating The Parser</h1>
<p>Now we update the parser. We do this by updating the <code>%tokentype</code> directive, the production rules, and our <code>%error</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>tokentype { <span class="dt">L.TokenExt</span> }</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>ident  { <span class="dt">L.TokenExt</span> (<span class="dt">L.Identifier</span> <span class="op">$$</span>) _ }</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>lambda { <span class="dt">L.TokenExt</span> <span class="dt">L.Lambda</span> _}</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;.&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.Dot</span> _ }</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;(&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.OpenParen</span> _ }</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;)&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.CloseParen</span> _ }</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="ot">parseError ::</span> [<span class="dt">L.TokenExt</span>] <span class="ot">-&gt;</span> a</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>parseError [] <span class="ot">=</span> <span class="fu">error</span>  <span class="st">&quot;ParseError: Empty token stream.&quot;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>parseError ((<span class="dt">L.TokenExt</span> tok pos)<span class="op">:</span>_) <span class="ot">=</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;ParseError: Unexpected token &#39;&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> tok <span class="op">&lt;&gt;</span> <span class="st">&quot;&#39; at line &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (L.line pos) <span class="op">&lt;&gt;</span> <span class="st">&quot;, column &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (L.col pos) <span class="op">&lt;&gt;</span> <span class="st">&quot;.&quot;</span></span></code></pre></div>
<p>Now we are logging the source position where we hit an unexpected token. However, what we really want to do is embed starting and ending positions (spans) inside all of our AST terms so that our hypothetical interpreter could provide nice error messages.</p>
<h1 id="adding-spans-to-our-ast">Adding Spans To Our AST</h1>
<p>Lets define a <code>Span</code> type and add it to the AST:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Span</span> <span class="ot">=</span> <span class="dt">Span</span> {<span class="ot"> start ::</span> <span class="dt">L.AlexSourcePos</span>,<span class="ot"> end ::</span> <span class="dt">L.AlexSourcePos</span> }</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Var</span> <span class="dt">Span</span> <span class="dt">String</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Abs</span> <span class="dt">Span</span> <span class="dt">String</span> <span class="dt">Term</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ap</span>  <span class="dt">Span</span> <span class="dt">Term</span>   <span class="dt">Term</span></span></code></pre></div>
<p>Now we need to update our terminal symbols in the <code>%tokentype</code> directive slightly:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ident  { <span class="dt">L.TokenExt</span> (<span class="dt">L.Identifier</span> _) _ }</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>lambda { <span class="dt">L.TokenExt</span> <span class="dt">L.Lambda</span> _}</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;.&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.Dot</span> _ }</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;(&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.OpenParen</span> _ }</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;)&#39;</span>    { <span class="dt">L.TokenExt</span> <span class="dt">L.CloseParen</span> _ }</span></code></pre></div>
<p>We removed the <code>$$</code> on the String value in <code>L.Identifer</code>. <code>$$</code> maps the terminal symbol to a subfield of our token constructor. By removing it, the <code>ident</code> lexeme now maps to the full <code>L.Tokenext
(L.Identifier xs) sp</code> value.</p>
<p>Now we can use the full <code>L.TokenExt</code> in our non-terminal production rules. Note, we already could do that for all terms but <code>L.Identifier _</code>, we just needed to update that one case.</p>
<p>If we throw a typehole in our production rule for <code>Var</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> ident { _ <span class="op">$</span><span class="dv">1</span> }</span></code></pre></div>
<p>We get:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>• <span class="dt">Found</span> hole<span class="op">:</span><span class="ot"> _ ::</span> <span class="dt">L.TokenExt</span> <span class="ot">-&gt;</span> t3</span></code></pre></div>
<p>Because we are matching on the <code>ident</code> terminal symbol we know that the <code>L.TokenExt</code> must contain <code>L.Identifier</code> and it is <em>ok</em> to write a partial function.</p>
<p>The last move is to update our production rules for <code>Var</code>, <code>Abs</code>, and <code>Ap</code> to generate spans, but before that we need a little API for working with spans.</p>
</body>
</html>
