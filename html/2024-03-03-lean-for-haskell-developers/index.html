<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Solomon Bothwell" />
    <title>Lean For Haskell Developers</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="runner1">SOLOMON'S BLOG</div>
<div id="runner1b">functional programming, permaculture, math</div>
<header id="title-block-header">
<h1 class="title">Lean For Haskell Developers</h1>
</header>
<p><strong>Last updated 2024-03-03</strong></p>
<p><a href="https://lean-lang.org/">Lean</a> is starting to look like a
great option for functional programming. It has been heavily adopted by
the mathematics community but no so much by the Functional Programming
community. This means that there is not yet much library support day to
application development, but the bones of the language look really nice
for FP.</p>
<p>Its a pure FP language with monadic effects, <code>do</code>
notation, typeclasses, and dependent types, quotient types, a powerful
macro system, a <code>C</code> FFI, and from what I understand it is
very fast.</p>
<p>At this point I wouldn't recommend it for production work outside of
theorem proving, but given some time that could change.</p>
<p>In my own personal interest I have created this minimal guide for
Haskell developers learning Lean. This article is not at all intended to
replace any of the much more substantial documentation generated by the
Lean community (and listed at the end of this article). Rather, this is
just a quick FAQ for common questions a Haskell developer will have when
starting to learn Lean. Contributions would be greatly appreciated <a
href="https://github.com/solomon-b/blog.cofree.coffee/issues">here</a>.</p>
<h2 id="installer">Installer</h2>
<p><a href="https://github.com/leanprover/elan">Elan</a> is Lean's
equivalent to GHCUp. It automatically puts lean and lake files in your
build path. Versions can be pinned via the <code>lean-toolchain</code>
file.</p>
<p>Elan is recommended even on Nixos systems and seems to integrate
fairly well.</p>
<h2 id="build-system">Build System</h2>
<p><a
href="https://github.com/leanprover/lean4/tree/master/src/lake">Lake</a>
is the standard build system. You can initialize a new project with:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> hello</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> hello</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">lake</span> init hello</span></code></pre></div>
<p>Dependencies and build targets are managed via
<code>lakefile.lean</code>.</p>
<h2 id="basic-syntax">Basic Syntax</h2>
<p>Note, most of these examples were taken from <a
href="https://lean-lang.org/functional_programming_in_lean">Functional
Programming in Lean</a> which is a much more complete introduction to
the language.</p>
<p>eval</p>
<p>You can drop the <code>#eval</code> meta command anywhere in your
code:</p>
<pre class="lean"><code>#eval 1 + 2
</code></pre>
<p>This can be triggered via LSP mode or the lean compiler directly.</p>
<p>Functions</p>
<p>Terms are defined using the <code>def</code> keyword:</p>
<pre class="lean"><code>def hello := &quot;Hello&quot;
</code></pre>
<p>The type of a term can be ascribed:</p>
<pre class="lean"><code>def lean : String := &quot;Lean&quot;
</code></pre>
<p>The basic way to define functions is by adding parameters (with or
without ascriptions) to a <code>def</code> statement:</p>
<pre class="lean"><code>def add1 (n : Nat) : Nat := n + 1
</code></pre>
<p>Lambdas are</p>
<p>Type Aliases</p>
<p>Because types are first class, we can define type aliases as ordinary
terms:</p>
<pre class="lean"><code>def Str : Type := String
def aStr : Str := &quot;This is a string.&quot;
</code></pre>
<p>Record Types</p>
<pre class="lean"><code>structure Point where
  x : Float
  y : Float
deriving Repr

def origin : Point := { x := 0.0, y := 0.0 }
</code></pre>
<p>Recursive and Sum Types</p>
<p>Both are declared with the <code>inductive</code> keyword:</p>
<pre class="lean"><code>inductive List (α : Type u) where
  | nil : List α
  | cons (head : α) (tail : List α) : List α

inductive Bool where
  | false : Bool
  | true : Bool
</code></pre>
<p>GADTs can also be done using <code>inductive</code> statements.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lit</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Str</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">String</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span></code></pre></div>
<p>Becomes:</p>
<pre class="lean"><code>inductive Expr : Type → Type
  | lit : Int → Expr Int
  | str : String → Expr String
  | add : Expr Int → Expr Int → Expr Int
</code></pre>
<p>Lean distinguishes between "normal" and "index" parameters. Normal
parameters must always be given first. Once an index parameter is
introduced, all subsequent paremeters are assumed to be indices as well.
This means we have to put the nat index on a Vec after the
<code>α</code> param:</p>
<pre class="lean"><code>inductive Vec : Type u → Nat → Type u where
  | vnil : Vec α 0
  | vcons (head : α) (tail : Vec α n) : Vec α (Nat.succ n)
</code></pre>
<p>More details found <a
href="https://lean-lang.org/functional_programming_in_lean/dependent-types/indices-parameters-universes.html">here</a>.</p>
<p>Pattern Matching</p>
<p><code>case</code> statements are called <code>match</code>
statments:</p>
<pre class="lean"><code>def isZero (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; false
</code></pre>
<p>Polymorphism</p>
<pre><code>structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>Sigma and Pi?</p>
<p>Lean is a dependently typed language which means it has Sigma and Pi
types. Explaining what that means is out of the scope of this FAQ. <a
href="https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html">Here</a>
is a more detailed article.</p>
<p>For reference here is their syntax to build a dependent pair</p>
<pre class="lean"><code>def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩
</code></pre>
<h2 id="hoogle">Hoogle?</h2>
<p>Lean has <a href="https://loogle.lean-lang.org/">loogle</a> which
does not appear work as well as Hoogle but I think that is inevitable
given that dependent types can require computation during
typechecking.</p>
<h2 id="effects-io">Effects? IO</h2>
<p>Lean has <a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Monad">Monads</a>!
Lean is a pure functional language with monadic effects and
<code>do</code> notation:</p>
<pre class="lean"><code>do a ← s,
 b ← t,
 f a b,
 return (g a b)
</code></pre>
<h2
id="functorapplicativemonadtraversable-etc">Functor/Applicative/Monad/Traversable
etc?</h2>
<p>Lean has a very similar typeclass hierarchy in the prelude:</p>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Functor">Init.Prelude.Functor</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Applicative">Init.Prelude.Applicative</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/Basic.html#Alternative">Init.Control.Basic.Alternative</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Monad">Init.Prelude.Monad</a></li>
</ul>
<p>Note that some common classes need to be found in
<code>Mathlib</code>. Classes requiring proofs are noted.</p>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Control/Bifunctor.html#Bifunctor">Mathlib.Control.Bifunctor.Bifunctor</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/Basic.html#MonadControl">Init.Control.Basic.MonadControl</a>
(MonadBaseControl)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Semigroup">Mathlib.Algebra.Group.Defs.Semigroup</a>
(requires proof)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid">Mathlib.Algebra.Group.Defs.Monoid</a>
(requires proof)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Control/Traversable/Basic.html#Traversable">Mathlib.Control.Traversable.Basic.Traversable</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Mathlib.CategoryTheory.Category.Basic.Category</a>
(requires proofs)</li>
</ul>
<p>Notably Absent</p>
<ul>
<li><code>Foldable</code> has been folded into
<code>Traversable</code>.</li>
<li><code>Profunctor</code> but should be recoverable using <a
href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Functor/Basic.html">CategoryTheory.Functor</a>
from <code>Mathlib</code> (requires proofs).</li>
</ul>
<h2 id="common-types">Common Types</h2>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Unit">Unit</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#List">Init.Prelude.List</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/Id.html#Id">Init.Control.Id</a>
(Identity)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/Reader.html">Init.Control.Reader</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/System/IO.html#IO">Init.System.IO</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/State.html">Init.Control.State</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Control/Option.html">Init.Control.Option</a>
(Maybe)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Except">Init.Prelude.Except</a>
(Either)</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Sum">Init.Core.Sum</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Std/Data/HashMap/Basic.html#Std.HashMap">Std.Data.HashMap.Basic.HashMap</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Array">Init.Prelude.Array</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#String">Init.Prelude.String</a>
<a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Data/String/Basic.html">Init.Data.String.Basic</a>
<a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Data/String/Extra.html">Init.Data.String.Extra</a></li>
</ul>
<h2 id="common-toolslibaries">Common Tools/Libaries</h2>
<p>JSON Serialization</p>
<p>Aeson style typeclasses can be found in mathlib:</p>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Json/FromToJson.html#Lean.FromJson">Lean.Data.Json.FromToJson.FromJSON</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Json/FromToJson.html#Lean.ToJson">Lean.Data.Json.FromToJson.ToJSON</a></li>
</ul>
<p>Web Servers/Clients/TLS/JOSE/JWT</p>
<p>To my knowledge nothing exists yet.</p>
<p>Parsing</p>
<p>Lean uses a non-monadic recursive descent parser: <a
href="https://leanprover-community.github.io/mathlib4_docs/Lean/Parser/Basic.html">https://leanprover-community.github.io/mathlib4_docs/Lean/Parser/Basic.html</a></p>
<p>To my knowledge no parser generator or parser combinator libraries
exist yet.</p>
<p>Database Clients</p>
<p>To my knowledge nothing exists yet.</p>
<p>File Handling, FilePaths, Directories, and Environment</p>
<p>This stuff is all mixed togther in the following modules:</p>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/System/IO.html">Init.System.IO</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/System/FilePath.html#System.FilePath">Init.System.FilePath</a></li>
</ul>
<p>IORefs/Mutation/Concurrency</p>
<ul>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/System/Mutex.html#IO.Mutex">IO.Mutex</a>
Similar to an IO Ref.</li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/System/Promise.html">IO.Promise</a></li>
<li><a
href="https://leanprover-community.github.io/mathlib4_docs/Init/Data/Channel.html#IO.Channel">Init.Data.Channel</a></li>
</ul>
<p>ST/STM</p>
<h2 id="package-registry">Package Registry?</h2>
<ul>
<li><a
href="https://reservoir.lean-lang.org/">https://reservoir.lean-lang.org/</a></li>
</ul>
<h2 id="where-can-i-learn-more">Where can I learn more?</h2>
<ul>
<li><a
href="https://reservoir.lean-lang.org/">https://reservoir.lean-lang.org/</a></li>
<li><a
href="https://leanprover-community.github.io/">https://leanprover-community.github.io/</a></li>
<li><a
href="https://lean-lang.org/lean4/doc/">https://lean-lang.org/lean4/doc/</a></li>
<li><a
href="https://lean-lang.org/functional_programming_in_lean/">https://lean-lang.org/functional_programming_in_lean/</a></li>
<li><a
href="https://leanprover.github.io/theorem_proving_in_lean4/">https://leanprover.github.io/theorem_proving_in_lean4/</a></li>
</ul>
</body>
</html>
