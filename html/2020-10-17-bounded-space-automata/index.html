<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Solomon Bothwell" />
  <meta name="description" content="Implementing cellular automata with Comonads, Representable Functors, and Dependent Types" />
  <title>Bounded Space Automata</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Bounded Space Automata</h1>
<p class="author">Solomon Bothwell</p>
</header>
<h2 id="rule-110">Rule 110</h2>
<p>After reading Chris Penner's blog post on <a href="https://chrispenner.ca/posts/conways-game-of-life">Conway's Game Of Life Using Representable and Comonads</a>, I decided to implement a similar solution for the 1 dimensional automata <a href="https://en.wikipedia.org/wiki/Rule_110">Rule 110</a>. Being such a simple algorithm I thought the implementation would be trivial. However, it turns out that working with arbitarily bounded spaces in the <code>Store Comonad</code> requires a clever use of dependent types to apply memoizaition as described in Chris' blog.</p>
<p>This blog post walks through my experience attempting to use <code>Store</code>, <code>Representable</code> in Haskell to implement Rule 110, difficulty finding a suitable <code>Representable</code> instance, and then a pivot to Idris where I was able to solve the problem using the finite set type <code>Fin n</code>.</p>
<p>The Rule 110 algorithm takes a vector of boolean values and applies a simple set of rules for transforming each index based upon its neighbors. You can think of it as a 1 dimensional variant of Conway's Game of Life, but with the twist that the first and last element of the vector are considered neighbors. In other words, the automata in Rule 110 exists on a circle rather then a line segment.</p>
<p>Here is the rubric for generating the new state for a given element:</p>
<table>
<tbody>
<tr class="odd">
<td>Current Pattern</td>
<td>111</td>
<td>110</td>
<td>101</td>
<td>100</td>
<td>011</td>
<td>010</td>
<td>001</td>
<td>000</td>
</tr>
<tr class="even">
<td>New State</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>This post assumes no prior knowledge of Comonads, Representable Functors, <code>Fin n</code>. The first few sections are intended to introduce these concepts by focusing on the actual implementations of their APIs.</p>
<h2 id="the-store-type-and-its-api">The Store Type and its API</h2>
<p>The <code>Store</code> type can be thought of as a way to query some indexable state along with a cursor that queries into the store at some index.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre></div>
<p>State is held implicitly in your query function and, as we shall see later, can be transformed through composition.</p>
<p>As an example, we can construct a <code>Store</code> whose implicit state is an infinite list of Booleans which we index into with an Integer:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">initialStore ::</span> <span class="dt">Store</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>initialStore <span class="ot">=</span> <span class="dt">Store</span> query <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      query ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      query i <span class="ot">=</span> (<span class="fu">cycle</span> [<span class="dt">True</span>, <span class="dt">False</span>]) <span class="op">!!</span> <span class="fu">abs</span> i</span></code></pre></div>
<p>The <code>Store</code> API then allows us to do things like query arbitrary indices, shift around our cursor, and through its <code>Functor</code> and <code>Comonad</code> instances to perform transformations on the implicit state held inside the query function.</p>
<p>Lets walk through the implementation of this API to gain a better intuition.</p>
<p>First we need a getter to lookup the current index:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pos ::</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> s</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pos (<span class="dt">Store</span> query s) <span class="ot">=</span> s</span></code></pre></div>
<p>Next, we want a way to query the <code>Store</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>peek s (<span class="dt">Store</span> query _) <span class="ot">=</span> query s</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">peeks ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>peeks f (<span class="dt">Store</span> query s) <span class="ot">=</span> query (f s)</span></code></pre></div>
<p><code>peek</code> disregards the current cursor and instead applies a new cursor to the store's query function. <code>peeks</code> uses a function <code>s -&gt;
  s</code> to modify the current cursor and then query the store with the new cursor.</p>
<p>We would also like a way to set and shift our cursor index:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">seek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>seek s (<span class="dt">Store</span> query _) <span class="ot">=</span> <span class="dt">Store</span> query s</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">seeks ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>seeks f (<span class="dt">Store</span> query s) <span class="ot">=</span> <span class="dt">Store</span> query (f s)</span></code></pre></div>
<p>This covers are basic getters and setters, but what if we wanted a way to query multiple indices into our store?</p>
<p>We might write this function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peekMany ::</span> [s] <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> [a]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>peekMany xs store <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">flip</span> peek store) xs</span></code></pre></div>
<p>This function looks pretty good, but notice we are using <code>fmap</code>. We can take advantage of polymorphism here allow use use of any <code>Functor</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peekFunctor ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> f a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>peekFunctor fs store <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">flip</span> peek store) fs</span></code></pre></div>
<p>Now we can use any <code>Functor</code> we want, but notice how we aren't using our cursor at all. This is a clue that we might be able to generalize this function further.</p>
<p>It would be great if we could modify <code>peekFunctor</code> to use our cursor value without losing the current behavior of the function.</p>
<p>If we replace the <code>f s</code> parameter with a function <code>s -&gt; f s</code> then we could apply the current cursor to our function and generate an <code>f
  s</code> to generate our <code>f a</code> output. Then if we want the precise behavior of <code>peekFunctor</code> we can simply apply <code>const (x :: f s)</code> and ignore the current cursor!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">experiment ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> f s) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> f a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>experiment f store <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">flip</span> peek store) (f (pos store))</span></code></pre></div>
<p>To recap our <code>Store</code> API we have:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pos ::</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">peek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">peeks ::</span> (s <span class="ot">-&gt;</span> s) <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">seek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">seeks ::</span> (s <span class="ot">-&gt;</span> s) <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">experiment ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> f s) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<h2 id="transformation-of-state">Transformation of State</h2>
<p>The state of the system is stored implicitely inside the <code>s -&gt; a</code> query function rather then in some data structure. Because of this, the only way to modify the state would be to modify the query function itself.</p>
<p>We can do this by first querying the current store to get an <code>a</code> value and then apply some <code>a -&gt; b</code> function to the value to produce a modified version of the state at that index.</p>
<p>We can do this by pattern matching on our <code>Store</code> then composing an <code>a -&gt; b</code> function with our query function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateStoreState ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>updateStoreState f (<span class="dt">Store</span> query s) <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> query) s</span></code></pre></div>
<p><code>updateStoreState</code> allows you to modify the query result for all possible values inside the Store's implicit state. This signature shoud look familiar as it is <code>fmap</code> and <code>Store</code> is in fact a <code>Functor</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s b</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Store</span> query s) <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> query) s</span></code></pre></div>
<p>Now we can model successive transformations of the state through applications of <code>fmap</code>. For example, using the <code>Store Int Bool</code> example from earlier, we might want to apply <code>not :: Bool -&gt; Bool</code> to invert the state of our system:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">initialStore ::</span> <span class="dt">Store</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>initialStore <span class="ot">=</span> <span class="dt">Store</span> query <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      query i <span class="ot">=</span> (<span class="fu">cycle</span> [<span class="dt">True</span>, <span class="dt">False</span>]) <span class="op">!!</span> i</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">newState ::</span> <span class="dt">Store</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>newState <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">not</span> initialStore</span></code></pre></div>
<p>Using equational reasoning we can translate that into:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>newState <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">not</span> initialStore</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">not</span> (<span class="dt">Store</span> query s)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=</span> <span class="dt">Store</span> (<span class="fu">not</span> <span class="op">.</span> query) s</span></code></pre></div>
<p>Using this technique to model 3 manipulations of a system shows how each modification to the implicit state builds up a larger composed query function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newState ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>newState h g f store <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g (<span class="fu">fmap</span> h store))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g (<span class="fu">fmap</span> h (<span class="dt">Store</span> query s)))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g (<span class="dt">Store</span> (h <span class="op">.</span> query) s))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Store</span> (g <span class="op">.</span> h <span class="op">.</span> query) s)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> g <span class="op">.</span> h <span class="op">.</span> query) s</span></code></pre></div>
<p>While elegant, modeling state transformations as function composition means that every time we query an index in a <code>Store</code>, we must recalculate every single previous transformation going back to the original <code>Store</code> query. Without caching these intermediate computations this will get very expensive.</p>
<p>Luckily, Chris Penner showed us a fantastic solution for this using Representable Functors. We will look at <code>Representable</code> shortly, but for now lets ignore the performance issue and focus on the tools we need to naively implement Rule 110.</p>
<h2 id="extending-our-api-with-comonad">Extending our API with Comonad</h2>
<p>Not only is <code>Store</code> a <code>Functor</code>, it is also a <code>Comonad</code>.</p>
<p><code>Comonads</code> are the dual of <code>Monads</code>. Where <code>Monads</code> introduce some effect to an argument via the form <code>a -&gt; m b</code>, <code>Comonads</code> introduce a notion of querying a structure for data (co-effects):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monadic</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">repeat</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Comonadic</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>w a <span class="ot">-&gt;</span> a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>The <code>Comonad</code> Typeclass has three functions:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    extract   ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre></div>
<p>Notice the inverse relation to <code>return</code>, <code>join</code>, and <code>(=&lt;&lt;)</code> from <code>Monad</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">duplicate ::</span> w a     <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">join      ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&lt;&lt;)  ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>If a defining characteristic of <code>Comonads</code> in Haskell is to provide a mechanism for querying some structure for data, then we can almost definitionally say that <code>Store</code> is a <code>Comonad</code>. <code>Store</code> is literally a mechnanism for querying a structure to produce data!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    extract ::</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    extract (<span class="dt">Store</span> query s) <span class="ot">=</span> query s</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    extend ::</span> (<span class="dt">Store</span> s a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s b</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    extend f (<span class="dt">Store</span> query s) <span class="ot">=</span> <span class="dt">Store</span> (\s&#39; <span class="ot">-&gt;</span> f (<span class="dt">Store</span> query s&#39;)) s</span></code></pre></div>
<p><code>extract</code> applies the current cursor to the query function and <code>extend</code> chains state transforming queries.</p>
<p><code>extract</code> is fairly trivial in this case, but <code>extend</code> is a little trickier. It helps to think about in relation to our <code>fmap</code> implementation.</p>
<p>Like <code>fmap</code>, it uses a function to modify our implicit state, but where <code>fmap</code> composed a pure <code>a -&gt; b</code> function with our query, <code>extend</code> creates a new query function by applying your entire store to a comonadic action. This allows us to bring into scope the entire current store when modifying particular points in the store.</p>
<p><code>extend</code> is extremely powerful and allows us to do really interesting things like create windowing functions and perform kernel convolution. It allows us to modify every single individual points in "parallel" using the entire state as context.</p>
<p>One interesting example of extend is to perform a moving average on some time series data.</p>
<p>First we need a <code>Store</code> modeling time sequenced data. We will use <code>Int</code> for our Index and it will represent a single unit of time in a data stream. We want some fairly dynamic data source so I chose the Fibbonaci sequence. At each point in time (each index) we get the next Fibbonaci number.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fibStore ::</span> <span class="dt">Store</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>fibStore <span class="ot">=</span> store query <span class="dv">0</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    query ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    query <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    query <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    query n <span class="ot">=</span> query (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> query (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Now, if we want to calculate a window starting from a given cursor want some way to query for the subsequent points in time. <code>experiement</code> will work perfectly here:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">window ::</span> <span class="dt">Store</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>window store <span class="ot">=</span> experiment (\s <span class="ot">-&gt;</span> [s<span class="op">..</span>s<span class="op">+</span><span class="dv">10</span>]) store</span></code></pre></div>
<p>I chose to fix the window at 10 units of time arbitrarily.</p>
<p>Now notice the shape of <code>window</code> is <code>Store Int a -&gt; [a]</code>. That looks a lot like the comonadic action for <code>extend</code>: <code>Store s a -&gt;
   b</code>. We can use <code>extend</code> to apply <code>window</code> over the enter store:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">windowedStore ::</span> <span class="dt">Store</span> <span class="dt">Int</span> [<span class="dt">Int</span>]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>windowedStore <span class="ot">=</span> extend window fibStore</span></code></pre></div>
<p>Now if we <code>peek</code> at any index in the store we see a window of the subsequent Fibonacci numbers!</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> peek <span class="dv">4</span> <span class="op">$</span> extend window fibStore</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">13</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">55</span>,<span class="dv">89</span>,<span class="dv">144</span>,<span class="dv">233</span>,<span class="dv">377</span>]</span></code></pre></div>
<h2 id="a-first-attempt-at-an-algorithm">A First Attempt at an Algorithm</h2>
<p>With the tools now available to us, we can make a first attempt at our Rule 110 algorithm.</p>
<p>The first step is to load our initial state into the <code>Store</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Index</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">initializeStore ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>initializeStore xs <span class="ot">=</span> <span class="dt">Store</span> query <span class="dv">0</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">      query ::</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>      query i <span class="ot">=</span> xs <span class="op">!!</span> i</span></code></pre></div>
<p>We are modeling our initial state as a list and using an unsafe list lookup function for our query. This isn't ideal, but we are just trying to put together a rough draft.</p>
<p>Next we need a way to query an index and its neighbors. Just like our windowing function, we can use <code>experiment</code> here.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbors ::</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>neighbors <span class="ot">=</span> experiment _lookupIndices</span></code></pre></div>
<p><code>_lookupIndices</code> is a type hole we need to fill. By starting from <code>neighborValues</code> we let GHC tell us what shape we need for <code>lookupIndices</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>• <span class="dt">Found</span> hole<span class="op">:</span><span class="ot"> _lookupIndices ::</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> [<span class="dt">Index</span>]</span></code></pre></div>
<p>We wan't something like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupIndices ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>lookupIndices s <span class="ot">=</span> [s<span class="op">-</span><span class="dv">1</span>, s, s<span class="op">+</span><span class="dv">1</span>]</span></code></pre></div>
<p>But which accounts for the fact that our automata lives on a circle not a line. We need to be able to identify the first and last index and use that information to select the correct neighbors.</p>
<p>The first, simplest solution is to pass in the length of the list as a value:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Index</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Size</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupIndices ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> [<span class="dt">Index</span>]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>lookupIndices size i</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> i <span class="op">==</span> <span class="dv">0</span>       <span class="ot">=</span> [size <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> i <span class="op">==</span> size <span class="op">-</span><span class="dv">1</span> <span class="ot">=</span> [i <span class="op">-</span> <span class="dv">1</span>, i, <span class="dv">0</span>]</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="fu">otherwise</span>    <span class="ot">=</span> [i <span class="op">-</span> <span class="dv">1</span>, i, i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbors ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Int</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>neighbors size <span class="ot">=</span> experiment (lookupIndices size)</span></code></pre></div>
<p>With a mechanism to lookup the state for our index and its neighbors, we next need to use that information to calculate the next state of at our index. We can do this by casing on the output of <code>neighborValues</code>:</p>
<p>Now we need to case on the state of the neighbors and apply our rubric to determine the new state at our index:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newState ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>newState size store <span class="ot">=</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> neighbors size store <span class="kw">of</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">False</span>, <span class="dt">False</span>, <span class="dt">False</span>] <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">False</span>]  <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">True</span>, <span class="dt">True</span>, <span class="dt">True</span>]    <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>Lastly, we need a way to apply this transformation to the entire store to create the next generation of the automata. <code>extend</code> to the rescue!</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextGen ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>nextGen size <span class="ot">=</span> extend (newState size)</span></code></pre></div>
<p>Lets use equational reasoning to take a closer look at what happens when you call <code>nextGen</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>nextGen size store <span class="ot">=</span> extend (newState size) store</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">=</span> extend (newState size) (<span class="dt">Store</span> query s)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">=</span> <span class="dt">Store</span> (\s&#39; <span class="ot">-&gt;</span> (newState size) (<span class="dt">Store</span> query s&#39;)) s</span></code></pre></div>
<p>And calling <code>nextGen</code> twice:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>nextGen size (nextGen size store) <span class="ot">=</span> extend (newState size) (extend (newState size) store)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">=</span> extend (newState size) (extend (newState size) (<span class="dt">Store</span> query s))</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">=</span> extend (newState size) (<span class="dt">Store</span> (\s&#39; <span class="ot">-&gt;</span> (newState size) (<span class="dt">Store</span> query s&#39;)) s)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">=</span> <span class="dt">Store</span> (\s&#39;&#39; <span class="ot">-&gt;</span> (newState size) (<span class="dt">Store</span> (\s&#39; <span class="ot">-&gt;</span> (newState size) (<span class="dt">Store</span> query s&#39;)) s&#39;&#39;)) s</span></code></pre></div>
<p>Its a little hard to grok, but if you squint your eyes a bit you can see that we are building up our <code>query</code> function by chaining calls of <code>newState</code> on the store. So whenever you query an index, the composed query function will apply <code>newState</code> a bunch of times to your store.</p>
<p>The last step to a working implementation is a function to view a store as a list. This isn't really a part of the algorithm per se, but we do want a way to view our results!</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">viewStore ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>viewStore size store <span class="ot">=</span> experiment (<span class="fu">const</span> [<span class="dv">0</span><span class="op">..</span>size]) store</span></code></pre></div>
<p>To run the simulation we can use a recursive function in <code>IO</code> to repeatedely print the result of <code>viewStore</code> and then call <code>nextGen</code> to update the state:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runSimulation ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> <span class="dt">Index</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>runSimulation size store <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> viewStore size store</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    runSimulation size <span class="op">$</span> nextGen size store</span></code></pre></div>
<p>This implementation does work, but if you try running it you will see that it has major performance issue. Extending a new generation means growing a chain of calls to <code>newState</code>.</p>
<p>This ever growing query function has to be calculated in full every time you peek into an index. We do that for every index at every generation when we call <code>runSimulation</code>.</p>
<p>Its actually worse then that though! To calculate the new state at each index we also have to peek at its neighbors. So that means for every index we are repeating the same huge query 3 times!</p>
<p>What we need is a way to memoize all these calculations.</p>
<h2 id="representable-functors">Representable Functors</h2>
<p>A <code>Functor</code> <code>f</code> is representable if it has a corresponding type <code>Rep f</code> that indexes <code>f</code> completely. There must be a valid index into <code>f</code> for every value of <code>Rep f</code> and at the same time we must be able to construct a container where each element in the container is produced from its <code>Rep f</code> index.</p>
<p>Another more formal way of stating this is that there must exist an isomorphism between <code>f a</code> and <code>Rep f -&gt; a</code>. This isomorphism is witnessed by the <code>tabulate</code> and <code>index</code> functions from the <code>Representable</code> typeclass:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Representable</span> f <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> f ::</span> <span class="op">*</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  tabulate ::</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  index    ::</span> f a <span class="ot">-&gt;</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>It's hard to see exactly how this would be useful to us, but there is a clever trick we can play with <code>Representable</code> to get memoization 'for free.'</p>
<p><code>tabulate</code> will takes some function that produces <code>a</code> values from <code>Rep f</code> values and then constructors a <code>Representable f</code> containing an <code>a</code> value for every possible <code>Rep f</code> value.</p>
<p><code>index</code> lets you use a <code>Rep f</code> to query a <code>Representable f</code> for <code>a</code> values. One nice property of <code>Representable</code> is that if you have a lawful instance then <code>index</code> must be a safe function without the need for <code>Maybe</code>!</p>
<p>Lets try to come up with a valid instance of <code>Representable</code>.</p>
<p>The most obvious first choice for <code>Functor</code> is <code>[]</code>, but what would we use for <code>Rep f</code>? <code>Int</code> doesn't work because you can't have a negative index into <code>[]</code>. <code>Nat</code> almost works, but then what happes if the list is empty? Unfortunately there is no <code>Representable</code> instance for <code>[]</code>.</p>
<p><code>NonEmpty</code> solves those problems, but it is still possible to have a <code>NonEmpty</code> without an element for every <code>Nat</code>.</p>
<p>What if our <code>Functor</code> was an infinite stream?</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">Strema</span> a)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Stream</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (f a) (<span class="fu">fmap</span> f as)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Representable</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Rep</span> f <span class="ot">=</span> <span class="dt">Nat</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    tabulate ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    tabulate f <span class="ot">=</span> <span class="dt">Cons</span> (f <span class="dt">Z</span>) (tabulate (f <span class="op">.</span> <span class="dt">S</span>))</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    index    ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> a</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> (<span class="dt">Cons</span> a as) <span class="dt">Z</span> <span class="ot">=</span> a</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> (<span class="dt">Cons</span> _ as) (<span class="dt">S</span> n) <span class="ot">=</span> <span class="fu">index</span> as n</span></code></pre></div>
<p>Yup! Our First <code>Representable</code>. Here is another somewhat trivial instance:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Identity</span> a) <span class="ot">=</span> <span class="dt">Identity</span> (f a)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Representable</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Rep</span> f <span class="ot">=</span> ()</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    tabulate ::</span> (() <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Identity</span> a</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    tabulate f <span class="ot">=</span> <span class="dt">Identity</span> <span class="op">$</span> f ()</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    index ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> () <span class="ot">-&gt;</span> a</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> (<span class="dt">Identity</span> a) () <span class="ot">=</span> a</span></code></pre></div>
<p>Since <code>Identity</code> can only hold a single <code>a</code> and <code>()</code> is inhabited by a single value, this instance lawful and total. :)</p>
<p>If our <code>Store</code> had a single element <code>Identity</code> would be perfect to represent queries into it and likewise, if it had an infinite amount of elements <code>Stream</code> might be perfect. However, we are looking for something in between.</p>
<p>What we need is some sort of bounded data structure, but in order to make it <code>Representable</code> we also need a corresponding bounded indexing type <code>Rep f</code>. <code>Identity</code> and <code>()</code> is a great example of a such a bounded <code>Representable</code>, but its bound at a fixed size of 1 element. We would like some <code>Functor f</code> and <code>Rep f</code> where we can fix the bound at whatever size we wish.</p>
<p>Another way of saying this is that we want is a family of <code>Representable</code> functors and a family of corresponding <code>Rep f</code> types, one pairing for each possible size boundary.</p>
<p>We can do this using <code>Vect n a</code> and <code>Fin n a</code>. <code>Vect</code> is a fixed length vector whose length is encoded with a type level <code>Nat</code>. <code>Fin</code> is a finite natural whose maximum value is encoded with a type level <code>Nat</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vect</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) a <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">VNil</span><span class="ot">  ::</span> <span class="dt">Vect</span> <span class="dt">Z</span> a</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">VCons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> n a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dt">S</span> n) a</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fin</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)</span></code></pre></div>
<p>And like that, we have entered the world of dependent types. A world very messy and confusing in Haskell. It is now time to switch over to Idris, but don't worry all the implementations up to this point are identical modulo a few small syntax changes.</p>
<p>Here is our <code>Representable</code> interface (Typeclass) in Idris and our instance for <code>Vect~/~Fin</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Representable</span> (f <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) (rep <span class="ot">:</span> <span class="dt">Type</span>) <span class="fu">|</span> f <span class="kw">where</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tabulate</span> <span class="ot">:</span> (rep <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">index</span> <span class="ot">:</span> f a <span class="ot">-&gt;</span> rep <span class="ot">-&gt;</span> a</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Representable</span> (<span class="dt">Vect</span> n) (<span class="dt">Fin</span> n) <span class="kw">where</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  tabulate f {n <span class="fu">=</span> <span class="dt">Z</span>} <span class="fu">=</span> []</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  tabulate f {n <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span> f <span class="dt">FZ</span> <span class="ot">::</span> tabulate (f <span class="fu">.</span> <span class="dt">FS</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  index (x <span class="ot">::</span> <span class="fu">_</span>) <span class="dt">FZ</span> {n <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span> x</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  index (<span class="fu">_</span> <span class="ot">::</span> xs) (<span class="dt">FS</span> x) {n <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span> index xs x</span></code></pre></div>
<p>In Idris there is no distinction between the "type level" and "term level." Types are first class values that can be passed around and worked with like any other values.</p>
<p>Correspondingly, type parameters (such as the <code>n</code> in <code>Vect n (Fin
   n)</code> are the same as term level parameters and can be passed into functions and pattern matched on. You can see this in the definition of <code>tabulate</code> above where the <code>n</code> from <code>Vect n</code> is wrapped in curly braces and treated like a function parameter.</p>
<p>The curly braces indicate that it is an implict parameter. This means that the typechecker is able to infer the value of the parameter and the caller never has to explicitely pass a value in. This might seem like magic, but its very similar to the type inference you are used to with Haskell.</p>
<p>With this instance of <code>Representable</code>, the indexing type <code>Fin n</code> cannot ever produce a value greater then <code>n - 1</code> and the <code>Functor</code> must be of size <code>n</code>. This is guaranteed at compile time.</p>
<p>This means that by choosing a different value for <code>n</code>, we can have a <code>Representable</code> instance for an arbitrary fixed length vector.</p>
<h2 id="using-representable-with-store">Using Representable with Store</h2>
<p>Now that we have switched over to Idris we need to rewrite our <code>Store</code> type. We also need to make it to work with <code>Representable</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkStore</span> <span class="ot">:</span> rep <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a</span></code></pre></div>
<p>This version of <code>Store</code> contains our current index (now called <code>rep</code>) and our <code>Representable</code> type <code>f a</code>. We no longer have a query function. Instead we are going to store our state as data in the <code>Representable Functor</code> and then use the <code>index</code> function to query it.</p>
<p>We then need to rewrite our API using <code>index</code> and <code>tabulate</code>. <code>peek</code> and <code>peeks</code>, and <code>extract</code> are all used for querying data so they will defined using <code>index</code>. <code>extend</code> is used for modifying our query so we know we will need to use <code>tabulate</code>.</p>
<p>Here is the full <code>Store</code> API in Idris:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pos</span> <span class="ot">:</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> rep</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>pos (<span class="dt">MkStore</span> rep&#39; fa) <span class="fu">=</span> rep&#39;</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="fu">peek</span> <span class="ot">:</span> <span class="dt">Representable</span> f rep <span class="ot">=&gt;</span> rep <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> a</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>peek rep&#39; (<span class="dt">MkStore</span> <span class="fu">_</span> fa) <span class="fu">=</span> index fa rep&#39;</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="fu">peeks</span> <span class="ot">:</span> <span class="dt">Representable</span> f rep <span class="ot">=&gt;</span> (rep <span class="ot">-&gt;</span> rep) <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> a</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>peeks f (<span class="dt">MkStore</span> rep&#39; fa) <span class="fu">=</span> index fa (f rep&#39;)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="fu">seek</span> <span class="ot">:</span> <span class="dt">Representable</span> f rep <span class="ot">=&gt;</span> rep <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>seek rep&#39; (<span class="dt">MkStore</span> <span class="fu">_</span> fa) <span class="fu">=</span> <span class="dt">MkStore</span> rep&#39; fa</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="fu">seeks</span> <span class="ot">:</span> <span class="dt">Representable</span> f rep <span class="ot">=&gt;</span> (rep <span class="ot">-&gt;</span> rep) <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>seeks func (<span class="dt">MkStore</span> rep&#39; fa) <span class="fu">=</span> <span class="dt">MkStore</span> (func rep&#39;) fa</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a><span class="fu">experiment</span> <span class="ot">:</span> (<span class="dt">Representable</span> f rep, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (rep <span class="ot">-&gt;</span> g rep) <span class="ot">-&gt;</span> <span class="dt">Store</span> f rep a <span class="ot">-&gt;</span> g a</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>experiment f s <span class="fu">=</span> map (<span class="fu">`peek`</span> s) (f (pos s))</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a><span class="dt">Representable</span> f rep <span class="ot">=&gt;</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> f rep) <span class="kw">where</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">MkStore</span> rep fa) <span class="fu">=</span> index fa rep</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>extend func (<span class="dt">MkStore</span> rep&#39; fa) <span class="fu">=</span> <span class="dt">MkStore</span> rep&#39; (tabulate (<span class="fu">\</span>rep&#39;&#39; <span class="ot">=&gt;</span> func (<span class="dt">MkStore</span> rep&#39;&#39; fa)))</span></code></pre></div>
<p>Again we use <code>index</code> to do our actual lookup inside the <code>f a</code>. The real magic is in <code>extend</code>. In our previous <code>Store</code>, extend created a new query function using a lambda which applied the initial <code>Store</code> to <code>f : Store s a -&gt; b</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>extend f (<span class="dt">Store&#39;</span> g s) <span class="ot">=</span> <span class="dt">Store</span> (\s&#39; <span class="ot">-&gt;</span> f (<span class="dt">Store</span> g s&#39;)) s</span></code></pre></div>
<p>In our new version, we do the exact same thing but then we pass the new query function into <code>tabulate :: (Fin n -&gt; Bool) -&gt; Vect (Fin
   N) Bool</code>, which uses that query function to generate the complete new state in a <code>Vect (Fin n)</code>.</p>
<p>Lets use equational reasoning to walk through a small example of <code>extend</code> where we pass in a function to extract the element at the current index and apply <code>not</code> to it. We can use that to create a small example where we walk through all the subsitutions.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">initialStore</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dt">Fin</span> <span class="dv">3</span>) (<span class="dt">Fin</span> <span class="dv">3</span>) <span class="dt">Bool</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>initialStore <span class="fu">=</span> <span class="dt">MkStore</span> <span class="dt">FZ</span> [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend (not <span class="fu">.</span> extract) initialStore</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> <span class="dt">FZ</span> [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>])</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> <span class="dt">FZ</span> (tabulate (<span class="fu">\</span>rep&#39; <span class="ot">=&gt;</span> extract (<span class="dt">MkStore</span> rep&#39; fa))))</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>                                  (  (<span class="fu">\</span>rep&#39;  <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; fa)) <span class="dt">FZ</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">::</span> ((<span class="fu">\</span>rep&#39; <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; fa)) <span class="fu">.</span> <span class="dt">FS</span>) <span class="dt">FZ</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">::</span> ((<span class="fu">\</span>rep&#39; <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; fa)) <span class="fu">.</span> <span class="dt">FS</span> <span class="fu">.</span> <span class="dt">FS</span>) <span class="dt">FZ</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>                                  <span class="ot">::</span> [])</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>                                  )</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>                          (  (<span class="fu">\</span><span class="dt">FZ</span>           <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> (<span class="fu">\</span>(<span class="dt">FS</span> <span class="dt">FZ</span>)      <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> (<span class="fu">\</span>(<span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)) <span class="ot">=&gt;</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> rep&#39; [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>                          (  (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> <span class="dt">FZ</span>           [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>])</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)      [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>])</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> (not <span class="fu">.</span> extract) (<span class="dt">MkStore</span> (<span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)) [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>])</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>                          (  not (extract (<span class="dt">MkStore</span> <span class="dt">FZ</span>           [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not (extract (<span class="dt">MkStore</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)      [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not (extract (<span class="dt">MkStore</span> (<span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)) [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]))</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>                          (  not (index [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>] <span class="dt">FZ</span>)</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not (index [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>] (<span class="dt">FS</span> <span class="dt">FZ</span>))</span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not (index [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>] (<span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)))</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>                          (  not <span class="dt">True</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not <span class="dt">False</span></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> not <span class="dt">True</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>                          (  <span class="dt">False</span></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> <span class="dt">True</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> <span class="dt">False</span></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">::</span> [])</span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a><span class="fu">=</span> extend extract (<span class="dt">MkStore</span> <span class="dt">FZ</span> [<span class="dt">False</span>, <span class="dt">True</span>, <span class="dt">False</span>])</span></code></pre></div>
<p>That example got a little big, but it demonstrates that the entire store transformation is done once and only once when you call <code>extend</code>. This is a huge improvement over having to recompute every prior generation every time you extend into a new generation.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The last thing to do is reimplement our algorith using our new version of <code>Store</code>. Other then switching languages, at this point we actually don't need to modify our code a whole bunch!</p>
<p>The biggest changes are updating type signatures and writing some clever helper functions to work with <code>Fin n</code>.</p>
<p>First we intialize the store:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">initialStore</span> <span class="ot">:</span> <span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>initialStore xs <span class="fu">=</span> <span class="dt">MkStore</span> <span class="dt">FZ</span> xs</span></code></pre></div>
<p>Lets take a closer look at this type signature:</p>
<ol>
<li>Notice the dependent type signature <code>Vect (3 + k) Bool</code>. This tells</li>
</ol>
<p>the compiler that the <code>Vect</code>'s size must be 3 greater then any <code>Nat</code>. The smallest possible <code>Nat</code> is 0 so this means that the <code>Vect</code> must be at a minimum length 3.</p>
<ol>
<li><p>Notice how in the <code>Store</code> our <code>Representable</code> is <code>Vect (3 + k)</code> and our <code>Rep f</code> is <code>Fin (3 + k)</code>. By sharing the same type variable <code>k</code> this tells the compiler that the <code>Fin</code> must be 3 greater then the exact same <code>Nat</code> as the <code>Vect</code>.</p></li>
<li><p>Lastly, notice how we no longer need to pass around our <code>Size</code> as a term. All the information we need is now encoded in the types. :)</p></li>
</ol>
<p>The next function we will need to rewrite is <code>indices</code>. This will require some clever tricks with <code>Fin</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">up</span> <span class="ot">:</span> <span class="dt">Fin</span> (<span class="dt">S</span> k) <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> k)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>up <span class="fu">=</span> either (const <span class="dt">FZ</span>) <span class="dt">FS</span> <span class="fu">.</span> strengthen</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="fu">down</span> <span class="ot">:</span> <span class="dt">Fin</span> (<span class="dt">S</span> k ) <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> k)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>down <span class="dt">FZ</span> <span class="fu">=</span> last</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>down (<span class="dt">FS</span> k) <span class="fu">=</span> weaken k</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="fu">indices</span> <span class="ot">:</span> <span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k) <span class="ot">-&gt;</span> <span class="dt">Vect</span> <span class="dv">3</span> (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k))</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>indices x <span class="fu">=</span> [down x, x, up x]</span></code></pre></div>
<p>When applying <code>FS</code> to produce the succesor to some <code>Fin n</code> we produce a <code>Fin (S n)</code>. Likewise, pattern matching and removing a <code>FS</code> from some <code>Fin (S k)</code> produces a <code>Fin k</code>.</p>
<p>This is a problem for us. We need to maintain the size of the finite set as an invariant thorughout our program. We have to use some tricks to shift our <code>Fin</code> values while maintaining the same size of set.</p>
<p>If <code>Fin (S k)</code> represents the finite set of naturals smaller then <code>k</code>, then we know morally that unwrapping <code>FS</code> constructors from our <code>Fin</code> does produce numbers that fit within <code>Fin (S k)</code>. We just need a way to demonstrate that to the type system.</p>
<p>Idris provides us with <code>weaken</code> and <code>strengthen</code> to do just this:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">weaken</span> <span class="ot">:</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">strengthen</span> <span class="ot">:</span> <span class="dt">Fin</span> (<span class="dt">S</span> n) <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Fin</span> (<span class="dt">S</span> n)) (<span class="dt">Fin</span> n)</span></code></pre></div>
<p><code>weaken</code> says that any <code>Fin n</code> is also a valid <code>Fin (S n)</code>. It's like saying any number <code>x</code> is smaller then <code>x + 1</code>. This allows us to unwrap one <code>FS</code> from our <code>Fin (S k)</code> to produce a number one digit smaller that is type <code>Fin k</code> and then convert it back to a <code>Fin (S k)</code>.</p>
<p><code>last</code> is another helper function from Idris that gives you the largest valid value for <code>Fin n</code>. In <code>down</code> we use pattern matching and <code>weaken</code> to produce a smaller <code>Fin n</code> in the successor case and <code>last</code> in the zero case to wrap around the modulus point.</p>
<p>In order to increase the value of a <code>x : Fin (S n)</code>, we need to show whether or not <code>x</code> is also a valid <code>Fin n</code>. eg., if <code>x</code> were 4, then it would be a member of the set of numbers 0 to 5 and the set 0 to 4 but not the set 0 to 3.</p>
<p><code>strengthen</code> says if <code>x : Fin (S n)</code> is too big to be a valid <code>Fin
  n</code> then return it as <code>Fin (S n)</code>, otherwise return it as <code>Fin
  n</code>. <code>up</code> is saying that if <code>x : Fin (S n)</code> is too big to be <code>Fin n</code> it must be the modulus point and we loop around to zero. Otherwise, we convert it to <code>Fin n</code> and apply <code>FS</code> to it to increment its value and keep the type as <code>Fin (S n)</code>.</p>
<p>The rest of the algorithm is as you would expect. The only changes were in the type signatures and removing the explicit threading of the size:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">neighbors</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Vect</span> <span class="dv">3</span> <span class="dt">Bool</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>neighbors <span class="fu">=</span> experiment indices</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="fu">isAlive</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>isAlive s <span class="fu">=</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> neighbors s <span class="kw">of</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">False</span>, <span class="dt">False</span>, <span class="dt">False</span>] <span class="ot">=&gt;</span> <span class="dt">False</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">False</span>] <span class="ot">=&gt;</span> <span class="dt">False</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">True</span>, <span class="dt">True</span>, <span class="dt">True</span>] <span class="ot">=&gt;</span> <span class="dt">False</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_</span> <span class="ot">=&gt;</span> <span class="dt">True</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="fu">nextGen</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>nextGen <span class="fu">=</span> extend isAlive</span></code></pre></div>
<p>The last thing we need is an updated <code>runSimulation</code> written in Idris:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">universe</span> <span class="ot">:</span> <span class="dt">Vect</span> k (<span class="dt">Fin</span> k)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>universe {k <span class="fu">=</span> <span class="dt">Z</span>} <span class="fu">=</span> []</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>universe {k <span class="fu">=</span> (<span class="dt">S</span> k)} <span class="fu">=</span> <span class="dt">FZ</span> <span class="ot">::</span> map <span class="dt">FS</span> (universe {k<span class="fu">=</span>k})</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="fu">boolToString</span> <span class="ot">:</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>boolToString <span class="dt">False</span> <span class="fu">=</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>boolToString <span class="dt">True</span> <span class="fu">=</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="fu">printState</span> <span class="ot">:</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>printState xs <span class="fu">=</span> <span class="kw">do</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  traverse_ (putStr <span class="fu">.</span> boolToString) <span class="fu">$</span> toList xs</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>  putStrLn <span class="st">&quot;&quot;</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="fu">runSimulation</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k)) (<span class="dt">Fin</span> (<span class="dv">3</span> <span class="fu">+</span> k)) <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>runSimulation s {k} <span class="fu">=</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> all id curr <span class="fu">||</span> all not curr</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>     <span class="kw">then</span> printState curr</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>     <span class="kw">else</span> printState curr <span class="fu">&gt;&gt;=</span> <span class="fu">\_</span> <span class="ot">=&gt;</span> runAutomata (nextGen s)</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">curr</span> <span class="ot">:</span> <span class="dt">Vect</span> (<span class="dv">3</span> <span class="fu">+</span> k) <span class="dt">Bool</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    curr <span class="fu">=</span> experiment (const universe) s</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>main <span class="fu">=</span> runSimulation init</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>   <span class="fu">start</span> <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">14</span> <span class="dt">Bool</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>   start <span class="fu">=</span> map (<span class="fu">\</span>i <span class="ot">=&gt;</span> <span class="kw">if</span> i <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span>) [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>   <span class="fu">init</span> <span class="ot">:</span> <span class="dt">Store</span> (<span class="dt">Vect</span> <span class="dv">14</span>) (<span class="dt">Fin</span> <span class="dv">14</span>) <span class="dt">Bool</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>   init <span class="fu">=</span> initialStore start</span></code></pre></div>
<p>And there it is! A type safe, performant implementation of Rule 110 using Comonads!</p>
</body>
</html>
