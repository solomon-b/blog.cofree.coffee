---
author: Solomon Bothwell
title: Lean For Haskell Developers
---

**Last updated 2024-03-03**

[Lean](https://lean-lang.org/) is starting to look like a great option
for functional programming. It has been heavily adopted by the
mathematics community but no so much by the Functional Programming
community. This means that there is not yet much library support day to
application development, but the bones of the language look really nice
for FP.

Its a pure FP language with monadic effects, `do` notation, typeclasses,
and dependent types, quotient types, a powerful macro system, a `C` FFI,
and from what I understand it is very fast.

At this point I wouldn\'t recommend it for production work outside of
theorem proving, but given some time that could change.

In my own personal interest I have created this minimal guide for
Haskell developers learning Lean. This article is not at all intended to
replace any of the much more substantial documentation generated by the
Lean community (and listed at the end of this article). Rather, this is
just a quick FAQ for common questions a Haskell developer will have when
starting to learn Lean. Contributions would be greatly appreciated
[here](https://github.com/solomon-b/blog.cofree.coffee/issues).

## Installer

[Elan](https://github.com/leanprover/elan) is Lean\'s equivalent to
GHCUp. It automatically puts lean and lake files in your build path.
Versions can be pinned via the `lean-toolchain` file.

Elan is recommended even on Nixos systems and seems to integrate fairly
well.

## Build System

[Lake](https://github.com/leanprover/lean4/tree/master/src/lake) is the
standard build system. You can initialize a new project with:

``` bash
mkdir hello
cd hello
lake init hello
```

Dependencies and build targets are managed via `lakefile.lean`.

## Basic Syntax

Note, most of these examples were taken from [Functional Programming in
Lean](https://lean-lang.org/functional_programming_in_lean) which is a
much more complete introduction to the language.

eval

You can drop the `#eval` meta command anywhere in your code:

``` lean
#eval 1 + 2
```

This can be triggered via LSP mode or the lean compiler directly.

Functions

Terms are defined using the `def` keyword:

``` lean
def hello := "Hello"
```

The type of a term can be ascribed:

``` lean
def lean : String := "Lean"
```

The basic way to define functions is by adding parameters (with or
without ascriptions) to a `def` statement:

``` lean
def add1 (n : Nat) : Nat := n + 1
```

Lambdas are

Type Aliases

Because types are first class, we can define type aliases as ordinary
terms:

``` lean
def Str : Type := String
def aStr : Str := "This is a string."
```

Record Types

``` lean
structure Point where
  x : Float
  y : Float
deriving Repr

def origin : Point := { x := 0.0, y := 0.0 }
```

Recursive and Sum Types

Both are declared with the `inductive` keyword:

``` lean
inductive List (α : Type u) where
  | nil : List α
  | cons (head : α) (tail : List α) : List α

inductive Bool where
  | false : Bool
  | true : Bool
```

GADTs can also be done using `inductive` statements.

``` haskell
data Expr a where
  Lit :: Int -> Expr Int
  Str :: String -> Expr String
  Add :: Expr Int -> Expr Int -> Expr Int
```

Becomes:

``` lean
inductive Expr : Type → Type
  | lit : Int → Expr Int
  | str : String → Expr String
  | add : Expr Int → Expr Int → Expr Int
```

Lean distinguishes between \"normal\" and \"index\" parameters. Normal
parameters must always be given first. Once an index parameter is
introduced, all subsequent paremeters are assumed to be indices as well.
This means we have to put the nat index on a Vec after the `α` param:

``` lean
inductive Vec : Type u → Nat → Type u where
  | vnil : Vec α 0
  | vcons (head : α) (tail : Vec α n) : Vec α (Nat.succ n)
```

More details found
[here](https://lean-lang.org/functional_programming_in_lean/dependent-types/indices-parameters-universes.html).

Pattern Matching

`case` statements are called `match` statments:

``` lean
def isZero (n : Nat) : Bool :=
  match n with
  | Nat.zero => true
  | Nat.succ k => false
```

Polymorphism

    structure PPoint (α : Type) where
      x : α
      y : α
    deriving Repr

Sigma and Pi?

Lean is a dependently typed language which means it has Sigma and Pi
types. Explaining what that means is out of the scope of this FAQ.
[Here](https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html)
is a more detailed article.

For reference here is their syntax to build a dependent pair

``` lean
def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩
```

## Hoogle?

Lean has [loogle](https://loogle.lean-lang.org/) which does not appear
work as well as Hoogle but I think that is inevitable given that
dependent types can require computation during typechecking.

## Effects? IO

Lean has
[Monads](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Monad)!
Lean is a pure functional language with monadic effects and `do`
notation:

``` lean
do a ← s,
 b ← t,
 f a b,
 return (g a b)
```

## Functor/Applicative/Monad/Traversable etc?

Lean has a very similar typeclass hierarchy in the prelude:

-   [Init.Prelude.Functor](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Functor)
-   [Init.Prelude.Applicative](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Applicative)
-   [Init.Control.Basic.Alternative](https://leanprover-community.github.io/mathlib4_docs/Init/Control/Basic.html#Alternative)
-   [Init.Prelude.Monad](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Monad)

Note that some common classes need to be found in `Mathlib`. Classes
requiring proofs are noted.

-   [Mathlib.Control.Bifunctor.Bifunctor](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Control/Bifunctor.html#Bifunctor)
-   [Init.Control.Basic.MonadControl](https://leanprover-community.github.io/mathlib4_docs/Init/Control/Basic.html#MonadControl)
    (MonadBaseControl)
-   [Mathlib.Algebra.Group.Defs.Semigroup](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Semigroup)
    (requires proof)
-   [Mathlib.Algebra.Group.Defs.Monoid](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid)
    (requires proof)
-   [Mathlib.Control.Traversable.Basic.Traversable](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Control/Traversable/Basic.html#Traversable)
-   [Mathlib.CategoryTheory.Category.Basic.Category](https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category)
    (requires proofs)

Notably Absent

-   `Foldable` has been folded into `Traversable`.
-   `Profunctor` but should be recoverable using
    [CategoryTheory.Functor](https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Functor/Basic.html)
    from `Mathlib` (requires proofs).

## Common Types

-   [Unit](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Unit)
-   [Init.Prelude.List](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#List)
-   [Init.Control.Id](https://leanprover-community.github.io/mathlib4_docs/Init/Control/Id.html#Id)
    (Identity)
-   [Init.Control.Reader](https://leanprover-community.github.io/mathlib4_docs/Init/Control/Reader.html)
-   [Init.System.IO](https://leanprover-community.github.io/mathlib4_docs/Init/System/IO.html#IO)
-   [Init.Control.State](https://leanprover-community.github.io/mathlib4_docs/Init/Control/State.html)
-   [Init.Control.Option](https://leanprover-community.github.io/mathlib4_docs/Init/Control/Option.html)
    (Maybe)
-   [Init.Prelude.Except](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Except)
    (Either)
-   [Init.Core.Sum](https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Sum)
-   [Std.Data.HashMap.Basic.HashMap](https://leanprover-community.github.io/mathlib4_docs/Std/Data/HashMap/Basic.html#Std.HashMap)
-   [Init.Prelude.Array](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Array)
-   [Init.Prelude.String](https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#String)
    [Init.Data.String.Basic](https://leanprover-community.github.io/mathlib4_docs/Init/Data/String/Basic.html)
    [Init.Data.String.Extra](https://leanprover-community.github.io/mathlib4_docs/Init/Data/String/Extra.html)

## Common Tools/Libaries

JSON Serialization

Aeson style typeclasses can be found in mathlib:

-   [Lean.Data.Json.FromToJson.FromJSON](https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Json/FromToJson.html#Lean.FromJson)
-   [Lean.Data.Json.FromToJson.ToJSON](https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Json/FromToJson.html#Lean.ToJson)

Web Servers/Clients/TLS/JOSE/JWT

To my knowledge nothing exists yet.

Parsing

Lean uses a non-monadic recursive descent parser:
<https://leanprover-community.github.io/mathlib4_docs/Lean/Parser/Basic.html>

To my knowledge no parser generator or parser combinator libraries exist
yet.

Database Clients

To my knowledge nothing exists yet.

File Handling, FilePaths, Directories, and Environment

This stuff is all mixed togther in the following modules:

-   [Init.System.IO](https://leanprover-community.github.io/mathlib4_docs/Init/System/IO.html)
-   [Init.System.FilePath](https://leanprover-community.github.io/mathlib4_docs/Init/System/FilePath.html#System.FilePath)

IORefs/Mutation/Concurrency

-   [IO.Mutex](https://leanprover-community.github.io/mathlib4_docs/Init/System/Mutex.html#IO.Mutex)
    Similar to an IO Ref.
-   [IO.Promise](https://leanprover-community.github.io/mathlib4_docs/Init/System/Promise.html)
-   [Init.Data.Channel](https://leanprover-community.github.io/mathlib4_docs/Init/Data/Channel.html#IO.Channel)

ST/STM

## Package Registry?

-   <https://reservoir.lean-lang.org/>

## Where can I learn more?

-   <https://reservoir.lean-lang.org/>
-   <https://leanprover-community.github.io/>
-   <https://lean-lang.org/lean4/doc/>
-   <https://lean-lang.org/functional_programming_in_lean/>
-   <https://leanprover.github.io/theorem_proving_in_lean4/>
