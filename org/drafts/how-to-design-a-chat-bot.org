#+AUTHOR: Solomon Bothwell
#+TITLE: How To Design A Chat Bot
#+DATE: 2022-02-12

I'm working on a [[https://github.com/cofree-coffee/cofree-bot][library]] for designing highly composable protocol
agnostic chat bots. The design is based on mealy machines and heavily
leverages Haskell's profunctor machinery. I want to walk through the
early stages of the design process and how you might arrive at such an
architecture.  

* What is a Chat Bot?
Lets start by describing what we mean by a chat bot, then lets factor
out as much as possible until we arrive at a precise, elegant
abstraction.

A chat bot is some persistant application that reads and produces
messages over a messaging protocol. Bots can optionally hold internal
state which they update via incoming messages and which they use to
produce outgoing messages.

Bots can also optionally perform side effects out of band from the
chat protocol. For example, a bot might execute an HTTP request and
then return the result in band through the chat protocol.

So a chat bot holds state, sends and receives messages over a chat
protocol, and can potentially perform out of band effects.

Now lets try to describe these actions more formally. We know that bot
must receieve input to produce an output and, if it is stateful,
produce a new state. We can describe these behaviors using lambdas:

#+begin_src haskell
  receive :: input -> state -> state
  receive = \input state -> _

  respond :: input -> state -> output
  respond = \input state -> _
#+end_src

Note: we pass in the old state to the lambda explicitly because we are
trying to develop explicit denotations of our behavior. We might hide
this explicit state passing somehow in our actual implementation.

We leave a typehole to represent the particular subroutine for this
bot.

~receive~ describes the act of updating the internal state from an
input and ~respond~ describes producing an output. We are still
missing the ability to perform out of band effects. We can describe
this by inscribing our outputs with an ~m~:

#+begin_src haskell
  receive :: input -> state -> m state
  receive = \input state -> _

  respond :: input -> state -> m output
  respond = \input state -> _
#+end_src

Now we have two precise, simple, and compelling /denotations/ of what
it means to receive and what it means to respond.

Our next task is take these independent denotations and compose them
together into a single larger denotation for what it means to /be a bot/.

#+begin_src haskell
  react :: state -> input -> (m state, m output)
  react = curry $ uncurry receive &&& uncurry respond

  bot :: Applicative m => state -> input -> m (state, output)
  bot = \state -> bisequence . react state
#+end_src

First we combine our denotations using ~&&&~, ~uncurry~, and
~curry~ as ~react~. Next we ~bisequence~ the result of ~react~.

Now we have a specification for a bot in the form of the signature for
~bot~. We have built this specification up from our smaller
denotations using well specified standard combinators. Nice!

Our last move is take this specification and throw it in a newtype
wrapper for use in our actual program:

#+begin_src haskell
  newtype Bot m s i o = Bot { runBot :: i -> s -> m (s, o) }
#+end_src

* Exploring Our Specification
Now that we have our bot specification, lets explore it a bit. We can
see that it /receives/ an ~i~ and an ~s~ and it /produces/ an ~s~ and
an ~o~. This means that it is ~Contravariant~ over ~i~, ~Covariant~
over ~o~, and ~Invariant~ over ~s~. This tells us that our ~Bot~ is a
~Functor~, a ~Profunctor~, and an ~Invariant Functor~. If it were
~Covariant~ on both ~i~ and ~o~ then it would be a ~Bifunctor~ rather
then a ~Profunctor~.

#+begin_src haskell
  instance Functor m => Functor (Bot m s i) where
    fmap :: (o -> o') -> Bot m s i o -> Bot m s i o'
    fmap f (Bot bot) = Bot $ \i s -> fmap (fmap f) $ bot i s
#+end_src

#+begin_src haskell
  instance Functor m => Profunctor (Bot m s) where
    dimap :: (i' -> i) -> (o -> o') -> Bot m s i o -> Bot m s i' o'
    dimap f g (Bot bot) = Bot $ \a -> fmap (fmap g) . bot (f a)
#+end_src

The order of type parameters doesn't allow the actual ~Invariant~
typeclass, but we can define ~invmap~:

#+begin_src haskell
  invmap :: Functor m => (s -> s') -> (s' -> s) -> Bot m s i o -> Bot m s' i o
  invmap f g (Bot b) = Bot $ \i s -> (b i (g s)) <&> bimap f id
#+end_src

Since ~Bot~ is a ~Profunctor~, lets take look at some other related structures:

#+begin_src haskell
  class Profunctor p => Strong p where
    first' :: p a b  -> p (a, c) (b, c)
    second' :: p a b -> p (c, a) (c, b)

  class Profunctor p => Choice p where
    left' :: p a b  -> p (Either a c) (Either b c)
    right' :: p a b -> p (Either c a) (Either c b)
#+end_src

~Strong~ describes a ~Profunctor~ where you can use a product to
'thread' an additional parameter through the ~Profunctor~. ~Choice~
describes the same property with respect to co-products.

It turns out ~Bot~ satisifies both:

#+begin_src haskell
  instance Functor m => Strong (Bot m s) where
    first' :: Bot m s i o -> Bot m s (i, c) (o, c)
    first' (Bot bot) = Bot $ \(a, c) -> fmap (fmap (, c)) . bot a

  instance Applicative m => Choice (Bot m s) where
    left' :: Bot m s i o -> Bot m s (Either i x) (Either o x)
    left' (Bot bot) = Bot $ \i s ->
      case i of
      Left a -> fmap (fmap Left) $ bot a s
      Right c -> pure (s, Right c)
#+end_src

One last structure we might try is ~Category~:

#+begin_src haskell
  instance Monad m => Category (Bot m s) where
    id :: Bot m s i i
    id = Bot $ \i s -> pure (s, i)

    (.) :: Bot m s b c -> Bot m s a b -> Bot m s a c
    (.) (Bot bot1) (Bot bot2) = Bot $ \a s -> do
      (s', b) <- bot2 a s
      bot1 b s'
#+end_src

The fact that we have ~Strong~ and ~Category~ means we also have
~Arrow~:

#+begin_src haskell
  instance Monad m => Arrow (Bot m s) where
    arr f = fmap f id
    first = first'
#+end_src

We will try to sort out the use of some of these structures later
on. For now, it is a great sign that our spec fits so many
well defined structures.

* Constructing Bots
Lets move on to building some bots. As we go along, we might discover
interesting uses for the structures defined previously.

We start with the simplest bot. Eg., one which receives and produces
~Text~ and operates with no state or monadic effects:

#+begin_src haskell
  simplestBot :: Bot Identity () Text Text
  simplestBot = Bot $ \i s -> pure (s, "Hello, " <> i)
#+end_src

This bot will respond to all messages with a fixed response.

We can simplify the construction of other pure, stateless bots with a
new combinator:

#+begin_src haskell
  pureStatelessBot :: Applicative m => (i -> o) -> Bot m s i o
  pureStatelessBot f = Bot $ \i s -> pure (s, f i)
#+end_src

We can leave the state and monad polymorphic because we simply thread
them through the bot. This allows a pure, stateless bot to be
used in an impure or stateful context.

We can also construct bots which perform monadic effects such as
random number generation in ~IO~:

#+begin_src haskell
  coinFlipBot :: Bot IO () () Bool
  coinFlipBot = Bot $ \_ s -> do
    gen <- newStdGen
    let (result, _) = random @Bool gen
    pure (s, result)
#+end_src

And of course, we could build a stateful bot:

#+begin_src haskell
  todoBot :: Applicative m => Bot m [T.Text] T.Text T.Text
  todoBot = Bot $ \i s ->
    case T.uncons i of
    Just ('>', todo) -> pure (todo:s, "Recorded todo!")
    Just ('<', _) | length s == 0 -> pure (s, "No more todos!")
    Just ('<', _) -> pure (tail s, head s)
    _ -> pure (s, "I didn't understand that.")
#+end_src

Notice that all of these bots /must/ return a response regardless of
the input. This is something we will need to address shortly.

* Interpretation
Now that we have a few bots, we need some way to run them. 

We can write a simple REPL-like bot interpreter. This will be a
function which receives a ~Bot IO s Text Text~ and produces a long
lived ~IO~ action that listens to STDIN as input to bot and prints the
output to STDOUT.

#+begin_src haskell
  runReplBot :: forall s. Bot IO s Text Text -> s -> IO ()
  runReplBot bot = go
    where
      go :: s -> IO ()
      go state = do
	putStr "> "
	hFlush stdout
	input <- fmap T.pack $ getLine
	result <- try @SomeException $ runBot bot input state
	case result of
	  Left _ -> go state
	  Right (nextState, output) -> do
	    putStrLn $ T.unpack output
	    go nextState
#+end_src
Note: This interpreter will only work with ~Bots~ polymorphic on ~m~
or where ~m ~ IO~. A more general ~replBot~ would have the signature:
~forall m s. (MonadCatch m, MonadIO m) => Bot m s Text Text -> s -> m
()~

We use ~try~ to capture exceptions as an ~Either~ value which we
ignore when recursing. This will make more sense later on.

Interpreters for arbitrary network protocols can be be written in the
same fashion. Choose appropriate input and output types for
resolving calls to your protocol of choice's API and then call out to
your API from an IO block.

We can use ~runReplBot~ to test out ~simplestBot~:

#+begin_src bash
  ghci> runReplBot simplestBot ()
  > World
  Hello, World
#+end_src

However, we still cannot run ~coinFlipBot~. We require a ~Bot IO s
Text Text~ and ~coinFlipBot~ is ~Bot IO s () Bool~.

To match it up with ~runReplBot~, we need a way to map ~Text -> ()~
for the input and ~Bool -> Text~ for the output. It turns out this is
precisely what ~Profunctor~ gives us!

#+begin_src haskell
  coinFlipBot' :: Bot IO () Text Text
  coinFlipBot' = dimap (const ()) (T.pack . show) coinFlipBot
#+end_src

One way to look at the behavior of ~coinFlipBot'~ is that it focuses
on a smaller input ~()~ inside of a larger structure ~Text~ and then
embeds a smaller output (~Bool~) inside a larger structure ~Text~.

Another way to say that is we have /parsed/ out of ~Text~ to pick a
~()~ and /pretty printed/ into ~Text~ to embed a ~Bool~.

Our work identifying algebraic structures is already paying off.

* Conditional Responses
Now we have defined a few simple bots and demonstrated how to
interpret them in a REPL-like environment. We still have an unsolved
problem, these bots are rather talkative. They must responsd to /all/
input they receieve. We need to sort out a way for bots to
conditionally produce output.

Our first thought might be to change our ~Bot~ type to either of:

#+begin_src haskell
  newtype Bot m s i o = Bot { runBot :: i -> s -> m (Maybe (s, o)) }
  newtype Bot m s i o = Bot { runBot :: i -> s -> m [(s, o)] }
#+end_src

However, both of those can break some desirable composition
behavior. Another option could be ~ListT~ from ~MTL~, but it has some
[[https://wiki.haskell.org/ListT_done_right][problems]]. The correct solution would be to use a Streaming
library--which is what we do in [[https://github.com/cofree-coffee/cofree-bot][the library]] that inspired this blog
post. The solution we have chosen for expediance here is to leverage
~Alternative~.

With ~IO~'s ~Alternative~, we can use ~empty~ to throw an exception
which we can catch in our interpreter. The exception handling is
already included in ~runReplBot~. Bots which don't specify a Monad
will get interpreted into ~IO~ and throw an exception when called from
~runReplBot~.

Lets see how this would work with ~coinFlipBot~:

#+begin_src haskell
  coinFlipBot' :: Bot IO () Text Text
  coinFlipBot' = Bot $ \i s ->
    if i == "flip a coin"
      then fmap (fmap (T.pack . show)) $ (runBot coinFlipBot) () s 
      else empty
#+end_src

We can no longer use ~dimap~ because our /focus/ operation is not pure
due to our use of ~empty~.

We can, however, define a new combinator ~lmapMaybe~ to generalize
over the optionality we just introduced and peel it out of
~coinFlipBot'~:

#+begin_src haskell
  lmapMaybe :: Alternative m => (i' -> Maybe i) -> Bot m s i o -> Bot m s i' o
  lmapMaybe f (Bot bot) = Bot $ \i' s ->
    case f i' of
      Nothing -> empty
      Just i -> bot i s

  coinFlipBot' :: Bot IO () Text Text
  coinFlipBot' = lmapMaybe parse $ fmap prettyPrint coinFlipBot
    where
      parse i = if i == "flip a coin" then Just () else Nothing
      prettyPrint = (T.pack . show)
#+end_src

What we are seeing in ~coinFlipBot'~ is contravariant and covariant
mappings of our input and output to /focus/ and /embed/ structures
respectively. In the contravariant case we are using a special
variation of ~lmap~ which leverages ~Alternative~ to produce optional
outputs.

* Composition
Our goal now is to take two bots and compose them together in
parallel as if they are a single bot with both behaviors. We
essentially have two ways to do this: we can either take the product
of their inputs and outputs or we can take their sum.

Both examples are interesting, but for this post lets stick with the
sum of two bots:

#+begin_src haskell
  infixr \/
  (\/) :: Functor m => Bot m s i o -> Bot m s i' o' -> Bot m s (Either i i') (Either o o')
  (\/) (Bot b1) (Bot b2) =
      Bot $ either ((fmap . fmap . fmap) Left . b1)
		   ((fmap . fmap . fmap) Right . b2)
#+end_src

We can use ~\/~ to compose a few bots:
#+begin_src haskell
  coinFlipBot :: Bot IO () () Bool
  coinFlipBot = Bot $ \_ s -> do
    gen <- newStdGen
    let (result, _) = random @Bool gen
    pure (s, result)

  diceRollBot :: Bot IO () () Int
  diceRollBot = Bot $ \i s -> do
    gen <- newStdGen
    let (result, _) = randomR @Int (1, 6) gen
    pure (s, result)

  sumBot :: Bot IO () (Either () ()) (Either Int Bool)
  sumBot = diceRollBot \/ coinFlipBot
#+end_src

~sumBot~ will execute a dice roll if it receives a ~Left ()~ or a coin
flip if it receives a ~Right ()~. We can then use ~lmapMaybe~ and a
few other tools to produce an approprate parser and pretty printer:

#+begin_src haskell
  sumBot' :: Bot IO () Text Text
  sumBot' = (lmapMaybe parse) $ fmap prettyPrint sumBot
    where
      parse :: Text -> Maybe (Either () ())
      parse "roll a die" = pure $ Left ()
      parse "flip a coin" = pure $ Right ()
      parse _ = empty

      prettyPrint :: Either Int Bool -> Text
      prettyPrint = indistinct . bimap (T.pack . show) (T.pack .show)

      indistinct :: Either a a -> a
      indistinct = either id id
#+end_src

#+begin_src bash
  ghci> runReplBot sumBot' ()
  > flip a coin
  True
  > roll a die
  4
  > x
  > 
#+end_src

* Transformations
At this point we can build bot behaviors around arbitrary inputs and
outputs, combine behaviors to produce composite bots, and interpret
them in arbitrary protocols. The last thing I want to explore in this
blog post is bot "transformations."

If we look at the kind of ~Bot~ we see:

#+begin_src bash
  type KBot = (Type -> Type) -> Type -> Type -> Type -> Type
#+end_src

Now, imagine something with kind ~KBot -> KBot~. This would represent
something that recieves a ~Bot~ and produces some other ~Bot~. I like
to call these ~Bot Transformers~. They offer another interesting way
to extend the behaviors of our bots.

For example, imagine we want to take one of our bots, such as
~coinFlipBot~, and run it on some protocol with distinct chat
rooms. We want our ~coinFlipBot~ to be able to receive messages
annotated with their source room and then produce messages annotated
with the target room.

We can define a ~Bot Transformer~ type to describe extending a bot
with this notion of 'room awareness':

#+begin_src haskell
  type RoomAware :: KBot -> KBot
  type RoomAware bot m s i o = bot m s (RoomID, i) (RoomID, o)
#+end_src

Now we need a function to inhabit this type. We are looking for
something that descibes the act of threading a type through our ~Bot~
via the product structure ~(,)~.

It just so happens that we already have that! This is precisely the
behavior of the ~Strong~ typeclass we implemented earlier:

#+begin_src haskell
  class Profunctor p => Strong p where
    first' :: p a b  -> p (a, c) (b, c)
    second' :: p a b -> p (c, a) (c, b)
#+end_src

This means we can make our ~coinFlipBot~ room aware through the
appliction of ~second'~:

#+begin_src haskell
  roomAwareBot :: RoomAware Bot IO () () Bool
  roomAwareBot = second' coinFlipBot
#+end_src

Another interesting bot transformation is adding session
state. Earlier we defined a ~todoBot~ which allowed a user to
construct a todo list. We might want to allow multiple users to store
their own todo lists. We could redesign the ~todoBot~ to support this
explicitly, but we want to be able to define precise bots with narrow
scopes which we can then extend through composition.

What we really want is a bot transformer that 'sessionizes' a
bot. This will involve transforming the bot's ~s~ state parameter in
addition to its input and output.

#+begin_src haskell
  newtype SessionState s = SessionState { sessions :: Map.Map Int s }
    deriving (Show, Semigroup, Monoid)

  data SessionInput i =
      InteractWithSession Int i
    | StartSession
    | EndSession Int

  data SessionOutput o =
      SessionOutput Int o
    | SessionStarted Int
    | SessionEnded Int
    | InvalidSession Int

  type Sessionized bot m s i o = Bot m (SessionState s) (SessionInput i) (SessionOutput o)
#+end_src

Now we need a function for sessionizing bots and a function to map
session inputs/outputs to ~Text~:
#+begin_src haskell

  sessionize
    :: Monad m
    => s
    -> Bot m s i o
    -> Sessionized m s i o
  sessionize = _

  simplifySessionBot
    :: forall m s i o
     . (Show s, Applicative m)
    => (o -> T.Text)
    -> (T.Text -> i)
    -> Bot m s (SessionInput i) (SessionOutput o)
    -> Bot m s Text Text
  simplifySessionBot = _
#+end_src

Definitions for ~sessionize~ and ~simplifySessionBot~ can be found in
the ~Cofree-Bot~ repo (or derived by the reader). The sessionized bot
tracks a ~Map~ of session states for your embedded bot and runs the
~Bot~ with the session requested by the user.

* Conclussion
We have demonstrated the core bot architecture as well as
constructing, interpreting, composing, and extending bots in various
dimensions. More so then explaining how to build a chat bot, I hope
this post inspires you to think more denotationally when designing
your own projects.
